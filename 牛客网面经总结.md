# JavaSE

## Java基础

### 请你比较一下Java和JavaSciprt？

JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。
下面对两种语言间的异同作如下比较：
\- **基于对象和面向对象**：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。
\- **解释和编译**：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）
\- **强类型变量和类型弱变量**：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。
\- 代码格式不一样。



### 请你说明一下，在Java中如何跳出当前的多重嵌套循环？

**在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。**（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好），根本不能进行字符串的equals比较，否则会产生NullPointerException异常。



### 请你讲讲&和&&的区别？

**&运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。**<u>逻辑与跟短路与</u>的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &&!username.equals("")，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。

补充：

按位与&：两位都为1结果才为1

按位或|：两位都为0结果才为零

异或^：两个位相同为0不同为1



### int和Integer有什么区别？

Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是**为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型**（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。
Java 为每个原始类型提供了包装类型：
\- 原始类型: boolean，char，byte，short，int，long，float，double
\- 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double



###  请你说明String 和StringBuffer的区别

JAVA 平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个**String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。**当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。 **StringBuffer的在进行字符串处理时，不生成新的对象，在内存使用上要优于串类。**



### 请你讲讲数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？

Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
Array大小是固定的，ArrayList的大小是动态变化的。
ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。



###  请你解释什么是值传递和引用传递？

值传递：在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是**将实参的值复制一份**传递到函数中，这样如果在函数中对该值（形参的值）进行了**操作将不会影响实参的值**。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。

引用传递：引用传递弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是**将对象的地址值传递**过去，函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，也就是说操作的其实都是源数据，所以方法的执行将**会影响到实际对象**。



### 请你讲讲Java支持的数据类型有哪些？什么是自动拆装箱？

Java语言支持的8种基本数据类型是：
byte
short
int
long
float
double
boolean
char
自动装箱是Java编译器**在基本数据类型和对应的对象包装类型之间做的一个转化**。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。



### 请你解释为什么会出现4.0-3.6=0.40000001这种现象？

2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。



###  请你讲讲一个十进制的数在内存中是怎么存的？

补码的形式

使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].

[详见](https://blog.csdn.net/zl10086111/article/details/80907428)



###  请你说说Lamda表达式的优缺点。

优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。

缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。



### 你知道java8的新特性吗，请简单介绍一下

**Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中）。**

方法引用− 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。

默认方法− 默认方法就是一个在接口里面有了一个实现的方法。

新工具− 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。

**Stream API** −新添加的Stream API（java.util.stream） **把真正的函数式编程风格引入到Java中**。

Date Time API − 加强对日期与时间的处理。

Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。

Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。



### 请你说明符号“==”比较的是什么？

**“”对比两个对象基于内存引用**，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回true，否则返回false。“==”**如果两边是基本类型，就是比较数值是否相等**。



###  请你解释为什么重写equals还要重写hashcode？

**Object中的equals方法是直接比较的地址**，因为Object类是所有类的基类，所以调用新创建的类的equals方法，比较的就是两个对象的地址。

所以我们需要重写equals方法，通过我们的规则来判断其是否相等。

```java
public class Student {

    private String name;
    private  int age;
    private  String QQ;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return age == student.age &&
                Objects.equals(name, student.name) &&
                Objects.equals(QQ, student.QQ);
    }
```
测试

```java
public class Test {
    public static void main(String[] args) {
        Student student = new Student();
        Student student2 = new Student();
        System.out.println(student.equals(student2));    //true
        System.out.println(student.hashCode());            //356573597
        System.out.println(student2.hashCode());           //1735600054 
        HashMap<Student, String> map = new HashMap<>();
        map.put(student,"123");
        map.put(student2,"456");
        System.out.println(map.get(student)); //123
        System.out.println(map.get(student2)); //456

    }
}
```

在上述测试中可以发现一个矛盾：用equals比较说明对象相同，但是在HashMap中却以不同的对象存储（相同的student对象 一个value为123 一个value为456）那这两个对象到底相等还是不相等呢？

出现这个情况的原因是我们没有重写hashcode方法，所以student和student2的hashcode不同 hashmap就将其作了不同的对象，所以我们需要重写hashcode

```java
public class Student {

    private String name;
    private  int age;
    private  String QQ;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return age == student.age &&
                Objects.equals(name, student.name) &&
                Objects.equals(QQ, student.QQ);
    }

    @Override
    public int hashCode() {

        return Objects.hash(name, age, QQ); //根据这三个属性生成hashcode
    }
}
```

测试

```java
public class Test {
    public static void main(String[] args) {
        Student student = new Student();
        Student student2 = new Student();
        System.out.println(student.equals(student2));   //true
        System.out.println(student.hashCode());          // 29791   
        System.out.println(student2.hashCode());       // 29791   
        HashMap<Student, String> map = new HashMap<>();
        map.put(student,"123");
        map.put(student2,"456");
        System.out.println(map.get(student));   //456
        System.out.println(map.get(student2)); //456

    }
}
```

此时发现 相同的对象student和student2value都为456（因为map.put(student2,"456")相当于覆盖了        map.put(student,"123");）

[详见](https://blog.csdn.net/We_chuan/article/details/96426273)



### 请你介绍一下map的分类和常见的情况

java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap.

Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。

<u>Hashmap</u> 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;**HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致**。如果需要同步，可以用 **Collections的synchronizedMap方法使HashMap具有同步的能力**，或者使用ConcurrentHashMap。**ConcurrentHashMap使用了分段锁技术来提高了并发度**，不在同一段的数据互相不影响，多个线程对多个不同的段的操作是不会相互影响的。每个段使用一把锁。

<u>Hashtable</u>与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;**它支持线程的同步，即任一时刻只有一个线程能写Hashtable**,因此也导致了 **Hashtable在写入时会比较慢**。

<u>LinkedHashMap</u> 是HashMap的一个子类，**保存了记录的插入顺序**，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为**LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。**

<u>TreeMap</u>实现SortMap接口，能够把它保存的记录**根据键排序**,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。

一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.

HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。

HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。

Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。

LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。

在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。



### 为什么HashMap线程不安全

HashMap的实现使用了一个数组，每个数组项里面有一个链表的方式来实现。因为HashMap使用key的hashCode来寻找存储位置，不同的key可能具有相同的hashCode，这时候就出现哈希冲突了，也叫做哈希碰撞，为了解决哈希冲突，有开放地址方法，以及链地址方法。HashMap的实现上选取了链地址方法，也就是将哈希值一样的entry保存在同一个数组项里面，可以把一个数组项当做一链表，链表里存了很多Node<k, v>

HashMap的初始数组的capacity为16，loadFact为0.75,当数组里面的数据记录超过阈值的时候，HashMap将会进行扩容则操作，每次都会将数组变为原来大小的2倍，然后将原先的记录逐个重新映射到新的数组里面，然后将原先的数组逐个置为null使得引用失效。直到设定的最大值之后就无法再resize了。

**1、put的时候导致的多线程数据不一致。**
 这个问题比较好想象，比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的数组的索引坐标，然后获取到该数组项里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的数组索引和线程B要插入的记录计算出来的数组索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。

**2、另外一个线程不安全的问题是HashMap的resize操作可能因为采取了头插法而引起死循环**

假设线程thread1执行到了transfer方法的Entry next = e.next这一句，然后时间片用完了，此时的e = [3,A], next = [7,B]。线程thread2被调度执行并且顺利完成了resize操作。之后线程thread1重新被调度运行**再创建一个新的数组**，此时的thread1持有的引用是已经被thread2 resize之后的结果，虽然此时e = [3,A], next = [7,B]，但是**此时的[7,B]的next为[3,A]**。

1.线程thread1首先将[3,A]迁移到**新的数组**上，然后再处理[7,B]。

2.处理完[7,B]之后，就需要处理[7,B]的next，而通过thread2的resize之后，由上述[7,B]的next变为了[3,A]

3.处理完[3, A]。此时，[3,A]和[7,B]形成了环形链表，在get的时候，如果get的key的数组索引和[3,A]和[7,B]一样，那么就会陷入死循环。

1. 对应数组索引 -> 3
2. 对应数组索引 -> 7 ->  3
3. 对应数组索引 -> 3 -> 7 -> 3

[大部分参考](https://www.jianshu.com/p/e2f75c8cce01)

[循环链表图参考](https://www.zhihu.com/question/28516433)



## 关键字

###  请你谈谈关于Synchronized和lock 

**1.synchronized是java中的一个关键字，也就是说是Java语言内置的特性。Lock则是一个接口**

**2.由于我们没办法设置synchronized关键字在获取锁的时候等待时间，所以synchronized可能会导致线程为了加锁而无限期地处于阻塞状态。**如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：

　　1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；

　　2）线程执行发生异常，此时JVM会让线程自动释放锁。

　　那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能地等待，非常影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock（可中断锁）就可以办到。

**3.使用synchronized关键字等同于使用了互斥锁，即其他线程都无法获得锁对象的访问权。这种策略对于读多写少的应用而言是很不利的，因为即使多个读者看似可以并发运行，但他们实际上还是串行的，并将最终导致并发性能的下降。**举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock（读写锁）就可以办到。

**4.采用synchronized不需要用户去手动释放锁**，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。

**5.通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。**

补充：

1.可重入锁

2.可中断锁

3.公平锁

4.读写锁

[详见](https://www.cnblogs.com/handsomeye/p/5999362.html)



### 请你介绍一下volatile？

**可见性**的意思是一个线程修改一个共享变量时，另一个线程可以读到这个修改的值，如果volatile使用恰当的话，它比synchronized的使用成本更低，因为它不会引起线程的上下文切换和调度。

**内存可见性 **

​	普通变量：对于读操作会先从工作内存当中读取，如果工作内存当中没有，会从主内存当中拷贝一份到工作内存，然后再进行读取，对于写操作，会直接操作工作内存当中的副本，什么时候写入到主内存中是不确定的，这种情况下，其他线程就无法获取到这个变量的最新值。

​	 volatile变量： 在读操作时，JMM会把工作内存当中的变量设置为无效，要求线程直接从主内存当中读取；写操作时，会把修改过的变量更新到主内存中去，其他线程就会拿到主内存当中地最新值。

**java当中原子性操作**就是，要么执行成功，要么执行失败，不会存在执行过程中被中断，在java内存模型当中，只有读取元素，赋值（将指定的数值赋值如i=4）操作是原子性操作, 其他的操作基本上都不是原子性操作，如果想要实现大面积的原子性操作，建议是使用synchronized关键字或者lock加锁，这样就能保证同一段代码，在某一个时刻只有一个线程在访问。

**java内存模型**规定所有的变量都存放在主内存当中，每个线程在执行的时候，会从主内存当中拷贝一份到自己的工作内存当中，线程对变量的读取，操作都是在工作内存当中执行的，不同线程之间也不能相互访问其他线程的工作内存，那么线程之间的变量传递需要通过主内存来实现共享。那么什么时候把修改过得变量更新到主内存当中去，就是多线程场景下需要解决的问题，否则将会造成数据的不一致。



**1.保证此变量对所有的线程的可见性。**要求线程直接从主内存当中读取

**2.禁止指令重排序优化。**有volatile修饰的变量，赋值后多执行内存屏障的操作（指令重排序时不能把后面的指令重排序到内存屏障之前的位置）

[详见](https://www.jianshu.com/p/157279e6efdb)



## 面向对象

### 若对一个类不重写，它的equals()方法是如何比较的？

比较是对象的地址。



### 请解释hashCode()和equals()方法有什么联系？

相等（相同）的对象必须具有相等的哈希码（或者散列码）。

但是两个对象的hashCode相同，它们并不一定相同。

重写equals方法时要记得重写hashCode方法



### 请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？

当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。
Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。
Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。



### 请说明Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？

Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。

方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表。**重载的方法不能根据返回类型进行区分，编译器通过各个方法给出的参数类型与特定方法调用所使用的值类型进行区分。**



### 请说明Query接口的list方法和iterate方法有什么区别？

1、返回的类型不同，list()返回List，iterate()返回Iterator

2、获取方式不同，list会一次性将数据库中的信息全部查询出，iterate会先把所有数据的id查询出来，然后真正要遍历某个对象的时候先到缓存中查找，如果找不到，以id为条件再发送一条sql到数据库，这样如果缓存中没有数据，则查询数据库的次数为n+1

3、list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。

4、list中返回的List中每个对象都是原本的对象，iterate中返回的对象是代理对象。（debug可以发现）



### 请你谈一下面向对象的"六原则一法则"。

**单一职责原则**：一个类只做它该做的事情。（单一职责原则想表达的就是"**高内聚**"，写代码最终极的原则只有六个字"高内聚、低耦合"，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是**模块化**，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）- 

**开闭原则**：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱

**依赖倒转原则**：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，**尽可能使用抽象类型而不用具体类型**，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）

**里氏替换原则**：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：<u>子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。</u>）-

**接口隔离原则**：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因<u>为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数</u>，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）-

**合成聚合复用原则**：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，**类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码**。需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）[使用聚合相对于使用继承的优点](https://www.cnblogs.com/feichengwulai/articles/3628122.html)

**迪米特法则**：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。