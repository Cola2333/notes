[原文1](https://blog.csdn.net/tanrui519521/article/details/80980135)

## 红黑树与AVL树的比较

1、AVL树的时间复杂度虽然优于红黑树，但是对于现在的计算机，cpu太快，可以忽略性能差异
2、红黑树的插入删除比AVL树更便于控制操作
3、红黑树整体性能略优于AVL树（红黑树旋转情况少于AVL树）



## 红黑树的性质

红黑树是一棵二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡。

**具体来说：**

1、节点是红色或者黑色

2、根节点是黑色

3、每个叶子的节点都是黑色的空节点（NULL）

4、每个红色节点的两个子节点都是黑色的。

5、从任意节点到其每个叶子的所有路径都包含相同的黑色节点

**为什么当满足以上性质时，就能保证最长路径不超过最短路径的二倍呢？**

其实细想一下，最短路径必然全为黑色节点，最长路径必然是黑红交错（性质4）。

再加上性质2、性质3和性质5。最长路径最多为最短路径的2n - 1。

![image-20200604165303866](C:\Users\WANG\AppData\Roaming\Typora\typora-user-images\image-20200604165303866.png)



## 红黑树的插入
RBTree为二叉搜索树，我们按照二叉搜索树的方法对其进行节点插入

RBTree有颜色约束性质，因此我们在插入新节点之后要进行颜色调整

具体步骤如下：

1、根节点为NULL，直接插入新节点并将其颜色置为黑色

2、根节点不为NULL，找到要插入新节点的位置 插入新节点，判断新插入节点对全树颜色的影响，更新调整颜色

**思考一个问题，你插入节点的默认颜色是RED或BLACK？** 

这里我们需要根据性质来思考

1、如果插入黑节点，这个可以直接插入无论它的父亲是什么颜色。但是红黑树的性质是每条路径的黑色节点数目相同，那么此时其他路径的黑色节点数目一定比当前路径少一个黑色节点，所以调整起来是非常繁琐的. 

2、如果插入红节点，则不需要调整其他路径。如果它的父亲为黑，那么直接插入，不需做任何调整。如果他的父亲为红，那么在该路径上面开始分情况调整. 所以插入节点默认颜色为红，如果为黑调节成本太大.



选择红色为默认颜色进行插入可以分为以下几种情况：

**一、cur为红，parent为红，uncle存在且为红，pParent为黑（根本原因是uncle为红）**

将parent节点和uncle节点变为黑，pParent节点变为红，这样我们就保证该子树中每条路径中黑色节点相同并且没有连续的红节点，然后再让cur等于pParent节点继续往上继续调整。

![](C:\WJJ\StudyInUSC\spring踩坑与学习\AVL树-images\20180710111745795.png)



**二、cur为红，parent为红，uncle不存在/uncle为黑，pParent为黑（根本原因是子情况为单旋 uncle不存在和uncle为黑并没有区别）**

+ **parent为pParent的左孩子，cur为parent的左孩子，uncle不存在**

  **parent为pParent的左孩子，cur为parent的左孩子，uncle为黑**

  将parent节点变黑，pParent节点变红，然后右单旋

  ![](C:\WJJ\StudyInUSC\spring踩坑与学习\AVL树-images\2018071011345053.png)

  ![](C:\WJJ\StudyInUSC\spring踩坑与学习\AVL树-images\2018071011332415.png)

+ **parent为pParent的右孩子，cur为parent的右孩子，uncle不存在**

  **parent为pParent的右孩子，cur为parent的右孩子，uncle为黑**

  将parent节点变黑，pParent节点变红，然后左单旋

  ![](C:\WJJ\StudyInUSC\spring踩坑与学习\AVL树-images\20180710114048597.png)

  ![](C:\WJJ\StudyInUSC\spring踩坑与学习\AVL树-images\20180710114008539.png)

**三、cur为红，parent为红，uncle不存在/uncle为黑，pParent为黑（其实和二归为一类，只不过子情况需要双旋）**

+ **parent为pParent的左孩子，cur为parent的右孩子，uncle不存在**

  **parent为pParent的左孩子，cur为parent的右孩子，uncle为黑**

  左单旋，即变为情况二的第一类子情况

  ![](C:\WJJ\StudyInUSC\spring踩坑与学习\AVL树-images\20180710121110758.png)

  ![](C:\WJJ\StudyInUSC\spring踩坑与学习\AVL树-images\20180710121014713.png)

+ **parent为pParent的右孩子，cur为parent的左孩子，uncle不存在**

  **parent为pParent的右孩子，cur为parent的左孩子，uncle为黑**

  右单旋，即变为情况二的第二类子情况

  ![](C:\WJJ\StudyInUSC\spring踩坑与学习\AVL树-images\20180710115905895.png)

  ![](C:\WJJ\StudyInUSC\spring踩坑与学习\AVL树-images\20180710115740161.png)



## 红黑树的删除